import { Ability } from '@casl/ability';

var can = {
  name: 'Can',
  functional: true,
  props: {
    I: String,
    do: String,
    a: [String, Function],
    of: [String, Function, Object],
    this: [String, Function, Object],
    on: [String, Function, Object],
    not: Boolean,
    passThrough: Boolean
  },
  render: function render(h, _ref) {
    var props = _ref.props,
        children = _ref.children,
        parent = _ref.parent,
        data = _ref.data;

    var _split = (props.I || props.do || '').split(' '),
        action = _split[0],
        field = _split[1];

    var subject = props.of || props.a || props.this || props.on;

    if (!action) {
      throw new Error('[Vue Can]: neither `I` nor `do` property exist');
    }

    if (!subject) {
      throw new Error('[Vue Can]: neither `of` nor `a` nor `this` nor `on` property exist');
    }

    var allowed = !!(props.not ^ parent.$can(action, subject, field));

    if (!props.passThrough) {
      return allowed ? children : null;
    }

    if (!data.scopedSlots || !data.scopedSlots.default) {
      throw new Error('[Vue Can]: `passThrough` expects default scoped slot to be specified');
    }

    return data.scopedSlots.default({
      allowed: allowed,
      ability: parent.$ability
    });
  }
};

var WATCHER_KEY = typeof Symbol === 'undefined' ? '__w' + Date.now() : Symbol('vue.watcher');

function abilitiesPlugin(Vue, providedAbility) {
  var defaultAbility = providedAbility || new Ability([]);

  function createWatcherFor(ability) {
    var watcher = new Vue({
      data: {
        rules: []
      }
    });

    ability.on('updated', function (event) {
      watcher.rules = event.rules;
    });

    ability[WATCHER_KEY] = watcher;

    return watcher;
  }

  Object.defineProperty(Vue.prototype, '$ability', {
    writable: true,
    value: defaultAbility
  });

  Vue.mixin({
    beforeCreate: function beforeCreate() {
      var _$options = this.$options,
          ability = _$options.ability,
          parent = _$options.parent;


      if (ability) {
        this.$ability = ability;
      } else if (parent && parent.$ability) {
        this.$ability = parent.$ability;
      }
    },


    methods: {
      $can: function $can() {
        var ability = this.$ability;
        var watcher = ability[WATCHER_KEY] ? ability[WATCHER_KEY] : createWatcherFor(ability);

        // create rendering dependency
        // eslint-disable-next-line
        watcher.rules = watcher.rules;

        return ability.can.apply(ability, arguments);
      }
    }
  });
}

export { can as Can, abilitiesPlugin };
